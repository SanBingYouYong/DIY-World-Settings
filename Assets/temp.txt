public class Test : MonoBehaviour
{
    public enum MoveMode
    {
        cam, 
        obj,
    }
    //上次⿏标位置
    Vector2 prevMousePos = Vector3.zero;
    //滑动结束时的瞬时速度
    Vector3 Speed = Vector3.zero;
    //每帧偏差
    Vector3 offSet = Vector3.zero;
    //⿏标开始位置
    Vector3 startMousePosition = Vector3.zero;
    //速度衰減率
    public float decelerationRate = 0.1f; 
    //摄像机
    public Camera m_camera;
    //移动模式
    public MoveMode m_moveMode = MoveMode.obj;
    
    void Update()
    {
        HandleMouseInput();
    }
    
    private void HandleMouseInput()
    {
        //按下时记录位置
        if (Input.GetMouseButtonDown(0))
        {
            prevMousePos = Input.mousePosition;
            startMousePosition = Input.mousePosition;
        }
        //移动时更新位置
        if (Input.GetMouseButton(0))
        {
            Vector3 curMousePosition = Input.mousePosition;   //当前⿏标的屏幕坐标系
            //偏差值
            offSet = m_camera.ScreenToWorldPoint(curMousePosition) - m_camera.ScreenToWorldPoint(prevMousePos);
            prevMousePos = curMousePosition;
            //瞬时速度
            Speed = offSet / Time.deltaTime;
        }
        else   //最后递减
        {
            Speed *= Mathf.Pow(decelerationRate, Time.deltaTime);
            if (Mathf.Abs(Vector3.Magnitude(Speed)) < 1)
            {
                Speed = Vector3.zero;
            }
        }
        Move(Speed);
    }
    
    public void Move(Vector3 speed)
    {
        if (Vector3.Magnitude(Speed) == 0)
        {
            return;
        }
        Debug.Log("Current Speed" + Vector3.Magnitude(speed));
        if (m_moveMode == MoveMode.obj)
        {
            transform.localPosition += speed * Time.deltaTime;
        }
        else
        {
            m_camera.transform.localPosition -= speed * Time.deltaTime;
        }
    }
}
--------------------------------------------------------
作者：两仪天容知识集
链接：https://wenku.baidu.com/view/b0bbbd5602f69e3143323968011ca300a6c3f6b2.html
来源：百度文库
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
--------------------------------------------------------
作者：两仪天容知识集
链接：https://wenku.baidu.com/view/b0bbbd5602f69e3143323968011ca300a6c3f6b2.html
来源：百度文库
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
--------------------------------------------------------
作者：两仪天容知识集
链接：https://wenku.baidu.com/view/b0bbbd5602f69e3143323968011ca300a6c3f6b2.html
来源：百度文库
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
--------------------------------------------------------
作者：两仪天容知识集
链接：https://wenku.baidu.com/view/b0bbbd5602f69e3143323968011ca300a6c3f6b2.html
来源：百度文库
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

某种计算超空间航道渲染坐标的方法
//GameObject newConnection = Instantiate(hyperspaceChannel, origin.transform, false) as GameObject;
                //// calculate middle point location: 
                //PointSystem neighborSys = allSystems.Find(sys => sys.id == neighborID);  // maybe change allSys to Dict for faster lookup?
                //float newX = (pointSystem.x + neighborSys.x) / 2;
                //float newY = (pointSystem.y + neighborSys.y) / 2;
                //float newZ = (pointSystem.z + neighborSys.z) / 2;
                //newConnection.transform.localPosition = new Vector3(newX, newY, newZ);
                //// calculate distance: 
                //float dist = Mathf.Sqrt(
                //    Mathf.Pow(pointSystem.x - neighborSys.x, 2) +
                //    Mathf.Pow(pointSystem.y - neighborSys.y, 2) +
                //    Mathf.Pow(pointSystem.z - neighborSys.z, 2));
                //// calculate rotation: 
                //float rotX = Mathf.Asin(Mathf.Abs(pointSystem.x - neighborSys.x) / dist) * 180 / Mathf.PI;
                //float rotY = Mathf.Asin(Mathf.Abs(pointSystem.y - neighborSys.y) / dist) * 180 / Mathf.PI;
                //float rotZ = Mathf.Asin(Mathf.Abs(pointSystem.z - neighborSys.z) / dist) * 180 / Mathf.PI;
                //newConnection.transform.localRotation = Quaternion.Euler(rotX, rotY, rotZ);
                //// 似乎完全可以通过xyz分别的sin（cos？）求度数赋值到旋转就行了？？
                ////float rotY = Mathf.Cos((pointSystem.x - neighborSys.x) /
                ////    Mathf.Sqrt(Mathf.Pow(pointSystem.x - neighborSys.x, 2) + Mathf.Pow(pointSystem.z - neighborSys.z, 2)));
                ////float rotZ = Mathf.Cos((pointSystem.x - neighborSys.x) / 
                ////    Mathf.Sqrt(Mathf.Pow(pointSystem.x - neighborSys.x, 2) + Mathf.Pow(pointSystem.y - neighborSys.y, 2)));
                //// 绕远路了。。。